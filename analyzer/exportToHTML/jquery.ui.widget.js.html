<html>
<head>
<title>jquery.ui.widget.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: rgb(0,0,0); font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); font-style: italic; }
.s1 { color: rgb(0,0,0); }
.s2 { color: rgb(0,0,128); font-weight: bold; }
.s3 { color: rgb(0,128,0); font-weight: bold; }
.s4 { color: rgb(0,0,255); }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#C0C0C0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
jquery.ui.widget.js</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">/*! jQuery UI - v1.11.1+CommonJS - 2014-09-17 
* http://jqueryui.com 
* Includes: widget.js 
* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */</span><span class="s1"> 
 
(</span><span class="s2">function</span><span class="s1">( factory ) { 
    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">define === </span><span class="s3">&quot;function&quot; </span><span class="s1">&amp;&amp; define.amd ) { 
 
        </span><span class="s0">// AMD. Register as an anonymous module.</span><span class="s1"> 
        define([ </span><span class="s3">&quot;jquery&quot; </span><span class="s1">], factory ); 
 
    } </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">exports === </span><span class="s3">&quot;object&quot;</span><span class="s1">) { 
        </span><span class="s0">// Node/CommonJS:</span><span class="s1"> 
        factory(require(</span><span class="s3">&quot;jquery&quot;</span><span class="s1">)); 
 
    } </span><span class="s2">else </span><span class="s1">{ 
 
        </span><span class="s0">// Browser globals</span><span class="s1"> 
        factory( jQuery ); 
    } 
}(</span><span class="s2">function</span><span class="s1">( $ ) { 
</span><span class="s0">/*! 
 * jQuery UI Widget 1.11.1 
 * http://jqueryui.com 
 * 
 * Copyright 2014 jQuery Foundation and other contributors 
 * Released under the MIT license. 
 * http://jquery.org/license 
 * 
 * http://api.jqueryui.com/jQuery.widget/ 
 */</span><span class="s1"> 
 
 
</span><span class="s2">var </span><span class="s1">widget_uuid = </span><span class="s4">0</span><span class="s1">, 
    widget_slice = Array.prototype.slice; 
 
$.cleanData = (</span><span class="s2">function</span><span class="s1">( orig ) { 
    </span><span class="s2">return function</span><span class="s1">( elems ) { 
        </span><span class="s2">var </span><span class="s1">events, elem, i; 
        </span><span class="s2">for </span><span class="s1">( i = </span><span class="s4">0</span><span class="s1">; (elem = elems[i]) != </span><span class="s2">null</span><span class="s1">; i++ ) { 
            </span><span class="s2">try </span><span class="s1">{ 
 
                </span><span class="s0">// Only trigger remove when necessary to save time</span><span class="s1"> 
                events = $._data( elem, </span><span class="s3">&quot;events&quot; </span><span class="s1">); 
                </span><span class="s2">if </span><span class="s1">( events &amp;&amp; events.remove ) { 
                    $( elem ).triggerHandler( </span><span class="s3">&quot;remove&quot; </span><span class="s1">); 
                } 
 
            </span><span class="s0">// http://bugs.jquery.com/ticket/8235</span><span class="s1"> 
            } </span><span class="s2">catch</span><span class="s1">( e ) {} 
        } 
        orig( elems ); 
    }; 
})( $.cleanData ); 
 
$.widget = </span><span class="s2">function</span><span class="s1">( name, base, prototype ) { 
    </span><span class="s2">var </span><span class="s1">fullName, existingConstructor, constructor, basePrototype, 
        </span><span class="s0">// proxiedPrototype allows the provided prototype to remain unmodified</span><span class="s1"> 
        </span><span class="s0">// so that it can be used as a mixin for multiple widgets (#8876)</span><span class="s1"> 
        proxiedPrototype = {}, 
        namespace = name.split( </span><span class="s3">&quot;.&quot; </span><span class="s1">)[ </span><span class="s4">0 </span><span class="s1">]; 
 
    name = name.split( </span><span class="s3">&quot;.&quot; </span><span class="s1">)[ </span><span class="s4">1 </span><span class="s1">]; 
    fullName = namespace + </span><span class="s3">&quot;-&quot; </span><span class="s1">+ name; 
 
    </span><span class="s2">if </span><span class="s1">( !prototype ) { 
        prototype = base; 
        base = $.Widget; 
    } 
 
    </span><span class="s0">// create selector for plugin</span><span class="s1"> 
    $.expr[ </span><span class="s3">&quot;:&quot; </span><span class="s1">][ fullName.toLowerCase() ] = </span><span class="s2">function</span><span class="s1">( elem ) { 
        </span><span class="s2">return </span><span class="s1">!!$.data( elem, fullName ); 
    }; 
 
    $[ namespace ] = $[ namespace ] || {}; 
    existingConstructor = $[ namespace ][ name ]; 
    constructor = $[ namespace ][ name ] = </span><span class="s2">function</span><span class="s1">( options, element ) { 
        </span><span class="s0">// allow instantiation without &quot;new&quot; keyword</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !</span><span class="s2">this</span><span class="s1">._createWidget ) { 
            </span><span class="s2">return new </span><span class="s1">constructor( options, element ); 
        } 
 
        </span><span class="s0">// allow instantiation without initializing for simple inheritance</span><span class="s1"> 
        </span><span class="s0">// must use &quot;new&quot; keyword (the code above always passes args)</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( arguments.length ) { 
            </span><span class="s2">this</span><span class="s1">._createWidget( options, element ); 
        } 
    }; 
    </span><span class="s0">// extend with the existing constructor to carry over any static properties</span><span class="s1"> 
    $.extend( constructor, existingConstructor, { 
        version: prototype.version, 
        </span><span class="s0">// copy the object used to create the prototype in case we need to</span><span class="s1"> 
        </span><span class="s0">// redefine the widget later</span><span class="s1"> 
        _proto: $.extend( {}, prototype ), 
        </span><span class="s0">// track widgets that inherit from this widget in case this widget is</span><span class="s1"> 
        </span><span class="s0">// redefined after a widget inherits from it</span><span class="s1"> 
        _childConstructors: [] 
    }); 
 
    basePrototype = </span><span class="s2">new </span><span class="s1">base(); 
    </span><span class="s0">// we need to make the options hash a property directly on the new instance</span><span class="s1"> 
    </span><span class="s0">// otherwise we'll modify the options hash on the prototype that we're</span><span class="s1"> 
    </span><span class="s0">// inheriting from</span><span class="s1"> 
    basePrototype.options = $.widget.extend( {}, basePrototype.options ); 
    $.each( prototype, </span><span class="s2">function</span><span class="s1">( prop, value ) { 
        </span><span class="s2">if </span><span class="s1">( !$.isFunction( value ) ) { 
            proxiedPrototype[ prop ] = value; 
            </span><span class="s2">return</span><span class="s1">; 
        } 
        proxiedPrototype[ prop ] = (</span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">var </span><span class="s1">_super = </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">return </span><span class="s1">base.prototype[ prop ].apply( </span><span class="s2">this</span><span class="s1">, arguments ); 
                }, 
                _superApply = </span><span class="s2">function</span><span class="s1">( args ) { 
                    </span><span class="s2">return </span><span class="s1">base.prototype[ prop ].apply( </span><span class="s2">this</span><span class="s1">, args ); 
                }; 
            </span><span class="s2">return function</span><span class="s1">() { 
                </span><span class="s2">var </span><span class="s1">__super = </span><span class="s2">this</span><span class="s1">._super, 
                    __superApply = </span><span class="s2">this</span><span class="s1">._superApply, 
                    returnValue; 
 
                </span><span class="s2">this</span><span class="s1">._super = _super; 
                </span><span class="s2">this</span><span class="s1">._superApply = _superApply; 
 
                returnValue = value.apply( </span><span class="s2">this</span><span class="s1">, arguments ); 
 
                </span><span class="s2">this</span><span class="s1">._super = __super; 
                </span><span class="s2">this</span><span class="s1">._superApply = __superApply; 
 
                </span><span class="s2">return </span><span class="s1">returnValue; 
            }; 
        })(); 
    }); 
    constructor.prototype = $.widget.extend( basePrototype, { 
        </span><span class="s0">// TODO: remove support for widgetEventPrefix</span><span class="s1"> 
        </span><span class="s0">// always use the name + a colon as the prefix, e.g., draggable:start</span><span class="s1"> 
        </span><span class="s0">// don't prefix for widgets that aren't DOM-based</span><span class="s1"> 
        widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name 
    }, proxiedPrototype, { 
        constructor: constructor, 
        namespace: namespace, 
        widgetName: name, 
        widgetFullName: fullName 
    }); 
 
    </span><span class="s0">// If this widget is being redefined then we need to find all widgets that</span><span class="s1"> 
    </span><span class="s0">// are inheriting from it and redefine all of them so that they inherit from</span><span class="s1"> 
    </span><span class="s0">// the new version of this widget. We're essentially trying to replace one</span><span class="s1"> 
    </span><span class="s0">// level in the prototype chain.</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( existingConstructor ) { 
        $.each( existingConstructor._childConstructors, </span><span class="s2">function</span><span class="s1">( i, child ) { 
            </span><span class="s2">var </span><span class="s1">childPrototype = child.prototype; 
 
            </span><span class="s0">// redefine the child widget using the same prototype that was</span><span class="s1"> 
            </span><span class="s0">// originally used, but inherit from the new version of the base</span><span class="s1"> 
            $.widget( childPrototype.namespace + </span><span class="s3">&quot;.&quot; </span><span class="s1">+ childPrototype.widgetName, constructor, child._proto ); 
        }); 
        </span><span class="s0">// remove the list of existing child constructors from the old constructor</span><span class="s1"> 
        </span><span class="s0">// so the old child constructors can be garbage collected</span><span class="s1"> 
        </span><span class="s2">delete </span><span class="s1">existingConstructor._childConstructors; 
    } </span><span class="s2">else </span><span class="s1">{ 
        base._childConstructors.push( constructor ); 
    } 
 
    $.widget.bridge( name, constructor ); 
 
    </span><span class="s2">return </span><span class="s1">constructor; 
}; 
 
$.widget.extend = </span><span class="s2">function</span><span class="s1">( target ) { 
    </span><span class="s2">var </span><span class="s1">input = widget_slice.call( arguments, </span><span class="s4">1 </span><span class="s1">), 
        inputIndex = </span><span class="s4">0</span><span class="s1">, 
        inputLength = input.length, 
        key, 
        value; 
    </span><span class="s2">for </span><span class="s1">( ; inputIndex &lt; inputLength; inputIndex++ ) { 
        </span><span class="s2">for </span><span class="s1">( key </span><span class="s2">in </span><span class="s1">input[ inputIndex ] ) { 
            value = input[ inputIndex ][ key ]; 
            </span><span class="s2">if </span><span class="s1">( input[ inputIndex ].hasOwnProperty( key ) &amp;&amp; value !== undefined ) { 
                </span><span class="s0">// Clone objects</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( $.isPlainObject( value ) ) { 
                    target[ key ] = $.isPlainObject( target[ key ] ) ? 
                        $.widget.extend( {}, target[ key ], value ) : 
                        </span><span class="s0">// Don't extend strings, arrays, etc. with objects</span><span class="s1"> 
                        $.widget.extend( {}, value ); 
                </span><span class="s0">// Copy everything else by reference</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    target[ key ] = value; 
                } 
            } 
        } 
    } 
    </span><span class="s2">return </span><span class="s1">target; 
}; 
 
$.widget.bridge = </span><span class="s2">function</span><span class="s1">( name, object ) { 
    </span><span class="s2">var </span><span class="s1">fullName = object.prototype.widgetFullName || name; 
    $.fn[ name ] = </span><span class="s2">function</span><span class="s1">( options ) { 
        </span><span class="s2">var </span><span class="s1">isMethodCall = </span><span class="s2">typeof </span><span class="s1">options === </span><span class="s3">&quot;string&quot;</span><span class="s1">, 
            args = widget_slice.call( arguments, </span><span class="s4">1 </span><span class="s1">), 
            returnValue = </span><span class="s2">this</span><span class="s1">; 
 
        </span><span class="s0">// allow multiple hashes to be passed on init</span><span class="s1"> 
        options = !isMethodCall &amp;&amp; args.length ? 
            $.widget.extend.apply( </span><span class="s2">null</span><span class="s1">, [ options ].concat(args) ) : 
            options; 
 
        </span><span class="s2">if </span><span class="s1">( isMethodCall ) { 
            </span><span class="s2">this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">var </span><span class="s1">methodValue, 
                    instance = $.data( </span><span class="s2">this</span><span class="s1">, fullName ); 
                </span><span class="s2">if </span><span class="s1">( options === </span><span class="s3">&quot;instance&quot; </span><span class="s1">) { 
                    returnValue = instance; 
                    </span><span class="s2">return false</span><span class="s1">; 
                } 
                </span><span class="s2">if </span><span class="s1">( !instance ) { 
                    </span><span class="s2">return </span><span class="s1">$.error( </span><span class="s3">&quot;cannot call methods on &quot; </span><span class="s1">+ name + </span><span class="s3">&quot; prior to initialization; &quot; </span><span class="s1">+ 
                        </span><span class="s3">&quot;attempted to call method '&quot; </span><span class="s1">+ options + </span><span class="s3">&quot;'&quot; </span><span class="s1">); 
                } 
                </span><span class="s2">if </span><span class="s1">( !$.isFunction( instance[options] ) || options.charAt( </span><span class="s4">0 </span><span class="s1">) === </span><span class="s3">&quot;_&quot; </span><span class="s1">) { 
                    </span><span class="s2">return </span><span class="s1">$.error( </span><span class="s3">&quot;no such method '&quot; </span><span class="s1">+ options + </span><span class="s3">&quot;' for &quot; </span><span class="s1">+ name + </span><span class="s3">&quot; widget instance&quot; </span><span class="s1">); 
                } 
                methodValue = instance[ options ].apply( instance, args ); 
                </span><span class="s2">if </span><span class="s1">( methodValue !== instance &amp;&amp; methodValue !== undefined ) { 
                    returnValue = methodValue &amp;&amp; methodValue.jquery ? 
                        returnValue.pushStack( methodValue.get() ) : 
                        methodValue; 
                    </span><span class="s2">return false</span><span class="s1">; 
                } 
            }); 
        } </span><span class="s2">else </span><span class="s1">{ 
            </span><span class="s2">this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">var </span><span class="s1">instance = $.data( </span><span class="s2">this</span><span class="s1">, fullName ); 
                </span><span class="s2">if </span><span class="s1">( instance ) { 
                    instance.option( options || {} ); 
                    </span><span class="s2">if </span><span class="s1">( instance._init ) { 
                        instance._init(); 
                    } 
                } </span><span class="s2">else </span><span class="s1">{ 
                    $.data( </span><span class="s2">this</span><span class="s1">, fullName, </span><span class="s2">new </span><span class="s1">object( options, </span><span class="s2">this </span><span class="s1">) ); 
                } 
            }); 
        } 
 
        </span><span class="s2">return </span><span class="s1">returnValue; 
    }; 
}; 
 
$.Widget = </span><span class="s2">function</span><span class="s1">( </span><span class="s0">/* options, element */ </span><span class="s1">) {}; 
$.Widget._childConstructors = []; 
 
$.Widget.prototype = { 
    widgetName: </span><span class="s3">&quot;widget&quot;</span><span class="s1">, 
    widgetEventPrefix: </span><span class="s3">&quot;&quot;</span><span class="s1">, 
    defaultElement: </span><span class="s3">&quot;&lt;div&gt;&quot;</span><span class="s1">, 
    options: { 
        disabled: </span><span class="s2">false</span><span class="s1">, 
 
        </span><span class="s0">// callbacks</span><span class="s1"> 
        create: </span><span class="s2">null</span><span class="s1"> 
    }, 
    _createWidget: </span><span class="s2">function</span><span class="s1">( options, element ) { 
        element = $( element || </span><span class="s2">this</span><span class="s1">.defaultElement || </span><span class="s2">this </span><span class="s1">)[ </span><span class="s4">0 </span><span class="s1">]; 
        </span><span class="s2">this</span><span class="s1">.element = $( element ); 
        </span><span class="s2">this</span><span class="s1">.uuid = widget_uuid++; 
        </span><span class="s2">this</span><span class="s1">.eventNamespace = </span><span class="s3">&quot;.&quot; </span><span class="s1">+ </span><span class="s2">this</span><span class="s1">.widgetName + </span><span class="s2">this</span><span class="s1">.uuid; 
        </span><span class="s2">this</span><span class="s1">.options = $.widget.extend( {}, 
            </span><span class="s2">this</span><span class="s1">.options, 
            </span><span class="s2">this</span><span class="s1">._getCreateOptions(), 
            options ); 
 
        </span><span class="s2">this</span><span class="s1">.bindings = $(); 
        </span><span class="s2">this</span><span class="s1">.hoverable = $(); 
        </span><span class="s2">this</span><span class="s1">.focusable = $(); 
 
        </span><span class="s2">if </span><span class="s1">( element !== </span><span class="s2">this </span><span class="s1">) { 
            $.data( element, </span><span class="s2">this</span><span class="s1">.widgetFullName, </span><span class="s2">this </span><span class="s1">); 
            </span><span class="s2">this</span><span class="s1">._on( </span><span class="s2">true</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.element, { 
                remove: </span><span class="s2">function</span><span class="s1">( event ) { 
                    </span><span class="s2">if </span><span class="s1">( event.target === element ) { 
                        </span><span class="s2">this</span><span class="s1">.destroy(); 
                    } 
                } 
            }); 
            </span><span class="s2">this</span><span class="s1">.document = $( element.style ? 
                </span><span class="s0">// element within the document</span><span class="s1"> 
                element.ownerDocument : 
                </span><span class="s0">// element is window or document</span><span class="s1"> 
                element.document || element ); 
            </span><span class="s2">this</span><span class="s1">.window = $( </span><span class="s2">this</span><span class="s1">.document[</span><span class="s4">0</span><span class="s1">].defaultView || </span><span class="s2">this</span><span class="s1">.document[</span><span class="s4">0</span><span class="s1">].parentWindow ); 
        } 
 
        </span><span class="s2">this</span><span class="s1">._create(); 
        </span><span class="s2">this</span><span class="s1">._trigger( </span><span class="s3">&quot;create&quot;</span><span class="s1">, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">this</span><span class="s1">._getCreateEventData() ); 
        </span><span class="s2">this</span><span class="s1">._init(); 
    }, 
    _getCreateOptions: $.noop, 
    _getCreateEventData: $.noop, 
    _create: $.noop, 
    _init: $.noop, 
 
    destroy: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">this</span><span class="s1">._destroy(); 
        </span><span class="s0">// we can probably remove the unbind calls in 2.0</span><span class="s1"> 
        </span><span class="s0">// all event bindings should go through this._on()</span><span class="s1"> 
        </span><span class="s2">this</span><span class="s1">.element 
            .unbind( </span><span class="s2">this</span><span class="s1">.eventNamespace ) 
            .removeData( </span><span class="s2">this</span><span class="s1">.widgetFullName ) 
            </span><span class="s0">// support: jquery &lt;1.6.3</span><span class="s1"> 
            </span><span class="s0">// http://bugs.jquery.com/ticket/9413</span><span class="s1"> 
            .removeData( $.camelCase( </span><span class="s2">this</span><span class="s1">.widgetFullName ) ); 
        </span><span class="s2">this</span><span class="s1">.widget() 
            .unbind( </span><span class="s2">this</span><span class="s1">.eventNamespace ) 
            .removeAttr( </span><span class="s3">&quot;aria-disabled&quot; </span><span class="s1">) 
            .removeClass( 
                </span><span class="s2">this</span><span class="s1">.widgetFullName + </span><span class="s3">&quot;-disabled &quot; </span><span class="s1">+ 
                </span><span class="s3">&quot;ui-state-disabled&quot; </span><span class="s1">); 
 
        </span><span class="s0">// clean up events and states</span><span class="s1"> 
        </span><span class="s2">this</span><span class="s1">.bindings.unbind( </span><span class="s2">this</span><span class="s1">.eventNamespace ); 
        </span><span class="s2">this</span><span class="s1">.hoverable.removeClass( </span><span class="s3">&quot;ui-state-hover&quot; </span><span class="s1">); 
        </span><span class="s2">this</span><span class="s1">.focusable.removeClass( </span><span class="s3">&quot;ui-state-focus&quot; </span><span class="s1">); 
    }, 
    _destroy: $.noop, 
 
    widget: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return this</span><span class="s1">.element; 
    }, 
 
    option: </span><span class="s2">function</span><span class="s1">( key, value ) { 
        </span><span class="s2">var </span><span class="s1">options = key, 
            parts, 
            curOption, 
            i; 
 
        </span><span class="s2">if </span><span class="s1">( arguments.length === </span><span class="s4">0 </span><span class="s1">) { 
            </span><span class="s0">// don't return a reference to the internal hash</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">$.widget.extend( {}, </span><span class="s2">this</span><span class="s1">.options ); 
        } 
 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">key === </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
            </span><span class="s0">// handle nested keys, e.g., &quot;foo.bar&quot; =&gt; { foo: { bar: ___ } }</span><span class="s1"> 
            options = {}; 
            parts = key.split( </span><span class="s3">&quot;.&quot; </span><span class="s1">); 
            key = parts.shift(); 
            </span><span class="s2">if </span><span class="s1">( parts.length ) { 
                curOption = options[ key ] = $.widget.extend( {}, </span><span class="s2">this</span><span class="s1">.options[ key ] ); 
                </span><span class="s2">for </span><span class="s1">( i = </span><span class="s4">0</span><span class="s1">; i &lt; parts.length - </span><span class="s4">1</span><span class="s1">; i++ ) { 
                    curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {}; 
                    curOption = curOption[ parts[ i ] ]; 
                } 
                key = parts.pop(); 
                </span><span class="s2">if </span><span class="s1">( arguments.length === </span><span class="s4">1 </span><span class="s1">) { 
                    </span><span class="s2">return </span><span class="s1">curOption[ key ] === undefined ? </span><span class="s2">null </span><span class="s1">: curOption[ key ]; 
                } 
                curOption[ key ] = value; 
            } </span><span class="s2">else </span><span class="s1">{ 
                </span><span class="s2">if </span><span class="s1">( arguments.length === </span><span class="s4">1 </span><span class="s1">) { 
                    </span><span class="s2">return this</span><span class="s1">.options[ key ] === undefined ? </span><span class="s2">null </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.options[ key ]; 
                } 
                options[ key ] = value; 
            } 
        } 
 
        </span><span class="s2">this</span><span class="s1">._setOptions( options ); 
 
        </span><span class="s2">return this</span><span class="s1">; 
    }, 
    _setOptions: </span><span class="s2">function</span><span class="s1">( options ) { 
        </span><span class="s2">var </span><span class="s1">key; 
 
        </span><span class="s2">for </span><span class="s1">( key </span><span class="s2">in </span><span class="s1">options ) { 
            </span><span class="s2">this</span><span class="s1">._setOption( key, options[ key ] ); 
        } 
 
        </span><span class="s2">return this</span><span class="s1">; 
    }, 
    _setOption: </span><span class="s2">function</span><span class="s1">( key, value ) { 
        </span><span class="s2">this</span><span class="s1">.options[ key ] = value; 
 
        </span><span class="s2">if </span><span class="s1">( key === </span><span class="s3">&quot;disabled&quot; </span><span class="s1">) { 
            </span><span class="s2">this</span><span class="s1">.widget() 
                .toggleClass( </span><span class="s2">this</span><span class="s1">.widgetFullName + </span><span class="s3">&quot;-disabled&quot;</span><span class="s1">, !!value ); 
 
            </span><span class="s0">// If the widget is becoming disabled, then nothing is interactive</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( value ) { 
                </span><span class="s2">this</span><span class="s1">.hoverable.removeClass( </span><span class="s3">&quot;ui-state-hover&quot; </span><span class="s1">); 
                </span><span class="s2">this</span><span class="s1">.focusable.removeClass( </span><span class="s3">&quot;ui-state-focus&quot; </span><span class="s1">); 
            } 
        } 
 
        </span><span class="s2">return this</span><span class="s1">; 
    }, 
 
    enable: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return this</span><span class="s1">._setOptions({ disabled: </span><span class="s2">false </span><span class="s1">}); 
    }, 
    disable: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return this</span><span class="s1">._setOptions({ disabled: </span><span class="s2">true </span><span class="s1">}); 
    }, 
 
    _on: </span><span class="s2">function</span><span class="s1">( suppressDisabledCheck, element, handlers ) { 
        </span><span class="s2">var </span><span class="s1">delegateElement, 
            instance = </span><span class="s2">this</span><span class="s1">; 
 
        </span><span class="s0">// no suppressDisabledCheck flag, shuffle arguments</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">suppressDisabledCheck !== </span><span class="s3">&quot;boolean&quot; </span><span class="s1">) { 
            handlers = element; 
            element = suppressDisabledCheck; 
            suppressDisabledCheck = </span><span class="s2">false</span><span class="s1">; 
        } 
 
        </span><span class="s0">// no element argument, shuffle and use this.element</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !handlers ) { 
            handlers = element; 
            element = </span><span class="s2">this</span><span class="s1">.element; 
            delegateElement = </span><span class="s2">this</span><span class="s1">.widget(); 
        } </span><span class="s2">else </span><span class="s1">{ 
            element = delegateElement = $( element ); 
            </span><span class="s2">this</span><span class="s1">.bindings = </span><span class="s2">this</span><span class="s1">.bindings.add( element ); 
        } 
 
        $.each( handlers, </span><span class="s2">function</span><span class="s1">( event, handler ) { 
            </span><span class="s2">function </span><span class="s1">handlerProxy() { 
                </span><span class="s0">// allow widgets to customize the disabled handling</span><span class="s1"> 
                </span><span class="s0">// - disabled as an array instead of boolean</span><span class="s1"> 
                </span><span class="s0">// - disabled class as method for disabling individual parts</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !suppressDisabledCheck &amp;&amp; 
                        ( instance.options.disabled === </span><span class="s2">true </span><span class="s1">|| 
                            $( </span><span class="s2">this </span><span class="s1">).hasClass( </span><span class="s3">&quot;ui-state-disabled&quot; </span><span class="s1">) ) ) { 
                    </span><span class="s2">return</span><span class="s1">; 
                } 
                </span><span class="s2">return </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">handler === </span><span class="s3">&quot;string&quot; </span><span class="s1">? instance[ handler ] : handler ) 
                    .apply( instance, arguments ); 
            } 
 
            </span><span class="s0">// copy the guid so direct unbinding works</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">handler !== </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
                handlerProxy.guid = handler.guid = 
                    handler.guid || handlerProxy.guid || $.guid++; 
            } 
 
            </span><span class="s2">var </span><span class="s1">match = event.match( </span><span class="s4">/^([\w:-]*)\s*(.*)$/ </span><span class="s1">), 
                eventName = match[</span><span class="s4">1</span><span class="s1">] + instance.eventNamespace, 
                selector = match[</span><span class="s4">2</span><span class="s1">]; 
            </span><span class="s2">if </span><span class="s1">( selector ) { 
                delegateElement.delegate( selector, eventName, handlerProxy ); 
            } </span><span class="s2">else </span><span class="s1">{ 
                element.bind( eventName, handlerProxy ); 
            } 
        }); 
    }, 
 
    _off: </span><span class="s2">function</span><span class="s1">( element, eventName ) { 
        eventName = (eventName || </span><span class="s3">&quot;&quot;</span><span class="s1">).split( </span><span class="s3">&quot; &quot; </span><span class="s1">).join( </span><span class="s2">this</span><span class="s1">.eventNamespace + </span><span class="s3">&quot; &quot; </span><span class="s1">) + </span><span class="s2">this</span><span class="s1">.eventNamespace; 
        element.unbind( eventName ).undelegate( eventName ); 
    }, 
 
    _delay: </span><span class="s2">function</span><span class="s1">( handler, delay ) { 
        </span><span class="s2">function </span><span class="s1">handlerProxy() { 
            </span><span class="s2">return </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">handler === </span><span class="s3">&quot;string&quot; </span><span class="s1">? instance[ handler ] : handler ) 
                .apply( instance, arguments ); 
        } 
        </span><span class="s2">var </span><span class="s1">instance = </span><span class="s2">this</span><span class="s1">; 
        </span><span class="s2">return </span><span class="s1">setTimeout( handlerProxy, delay || </span><span class="s4">0 </span><span class="s1">); 
    }, 
 
    _hoverable: </span><span class="s2">function</span><span class="s1">( element ) { 
        </span><span class="s2">this</span><span class="s1">.hoverable = </span><span class="s2">this</span><span class="s1">.hoverable.add( element ); 
        </span><span class="s2">this</span><span class="s1">._on( element, { 
            mouseenter: </span><span class="s2">function</span><span class="s1">( event ) { 
                $( event.currentTarget ).addClass( </span><span class="s3">&quot;ui-state-hover&quot; </span><span class="s1">); 
            }, 
            mouseleave: </span><span class="s2">function</span><span class="s1">( event ) { 
                $( event.currentTarget ).removeClass( </span><span class="s3">&quot;ui-state-hover&quot; </span><span class="s1">); 
            } 
        }); 
    }, 
 
    _focusable: </span><span class="s2">function</span><span class="s1">( element ) { 
        </span><span class="s2">this</span><span class="s1">.focusable = </span><span class="s2">this</span><span class="s1">.focusable.add( element ); 
        </span><span class="s2">this</span><span class="s1">._on( element, { 
            focusin: </span><span class="s2">function</span><span class="s1">( event ) { 
                $( event.currentTarget ).addClass( </span><span class="s3">&quot;ui-state-focus&quot; </span><span class="s1">); 
            }, 
            focusout: </span><span class="s2">function</span><span class="s1">( event ) { 
                $( event.currentTarget ).removeClass( </span><span class="s3">&quot;ui-state-focus&quot; </span><span class="s1">); 
            } 
        }); 
    }, 
 
    _trigger: </span><span class="s2">function</span><span class="s1">( type, event, data ) { 
        </span><span class="s2">var </span><span class="s1">prop, orig, 
            callback = </span><span class="s2">this</span><span class="s1">.options[ type ]; 
 
        data = data || {}; 
        event = $.Event( event ); 
        event.type = ( type === </span><span class="s2">this</span><span class="s1">.widgetEventPrefix ? 
            type : 
            </span><span class="s2">this</span><span class="s1">.widgetEventPrefix + type ).toLowerCase(); 
        </span><span class="s0">// the original event may come from any element</span><span class="s1"> 
        </span><span class="s0">// so we need to reset the target on the new event</span><span class="s1"> 
        event.target = </span><span class="s2">this</span><span class="s1">.element[ </span><span class="s4">0 </span><span class="s1">]; 
 
        </span><span class="s0">// copy original event properties over to the new event</span><span class="s1"> 
        orig = event.originalEvent; 
        </span><span class="s2">if </span><span class="s1">( orig ) { 
            </span><span class="s2">for </span><span class="s1">( prop </span><span class="s2">in </span><span class="s1">orig ) { 
                </span><span class="s2">if </span><span class="s1">( !( prop </span><span class="s2">in </span><span class="s1">event ) ) { 
                    event[ prop ] = orig[ prop ]; 
                } 
            } 
        } 
 
        </span><span class="s2">this</span><span class="s1">.element.trigger( event, data ); 
        </span><span class="s2">return </span><span class="s1">!( $.isFunction( callback ) &amp;&amp; 
            callback.apply( </span><span class="s2">this</span><span class="s1">.element[</span><span class="s4">0</span><span class="s1">], [ event ].concat( data ) ) === </span><span class="s2">false </span><span class="s1">|| 
            event.isDefaultPrevented() ); 
    } 
}; 
 
$.each( { show: </span><span class="s3">&quot;fadeIn&quot;</span><span class="s1">, hide: </span><span class="s3">&quot;fadeOut&quot; </span><span class="s1">}, </span><span class="s2">function</span><span class="s1">( method, defaultEffect ) { 
    $.Widget.prototype[ </span><span class="s3">&quot;_&quot; </span><span class="s1">+ method ] = </span><span class="s2">function</span><span class="s1">( element, options, callback ) { 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">options === </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
            options = { effect: options }; 
        } 
        </span><span class="s2">var </span><span class="s1">hasOptions, 
            effectName = !options ? 
                method : 
                options === </span><span class="s2">true </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">options === </span><span class="s3">&quot;number&quot; </span><span class="s1">? 
                    defaultEffect : 
                    options.effect || defaultEffect; 
        options = options || {}; 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">options === </span><span class="s3">&quot;number&quot; </span><span class="s1">) { 
            options = { duration: options }; 
        } 
        hasOptions = !$.isEmptyObject( options ); 
        options.complete = callback; 
        </span><span class="s2">if </span><span class="s1">( options.delay ) { 
            element.delay( options.delay ); 
        } 
        </span><span class="s2">if </span><span class="s1">( hasOptions &amp;&amp; $.effects &amp;&amp; $.effects.effect[ effectName ] ) { 
            element[ method ]( options ); 
        } </span><span class="s2">else if </span><span class="s1">( effectName !== method &amp;&amp; element[ effectName ] ) { 
            element[ effectName ]( options.duration, options.easing, callback ); 
        } </span><span class="s2">else </span><span class="s1">{ 
            element.queue(</span><span class="s2">function</span><span class="s1">( next ) { 
                $( </span><span class="s2">this </span><span class="s1">)[ method ](); 
                </span><span class="s2">if </span><span class="s1">( callback ) { 
                    callback.call( element[ </span><span class="s4">0 </span><span class="s1">] ); 
                } 
                next(); 
            }); 
        } 
    }; 
}); 
 
</span><span class="s2">var </span><span class="s1">widget = $.widget; 
 
 
 
})); 
</span></pre>
</body>
</html>